<p>People sometimes write code like this when they want to handle the asynchronous error by invoking the <code>callback</code> function and passing the error as an argument. But they make the mistake of thinking that if they <code>throw</code> it from their own callback (the function passed to <code>doSomeAsynchronousOperation</code>), then it can be caught in the <code>catch</code> block. That's not how <code>try</code>/<code>catch</code> work with asynchronous functions. Recall that the whole point of an asynchronous function is that it's invoked some time <em>later</em>, after <code>myApiFunc</code> returns. That means the <code>try</code> block has been exited. The callback is invoked directly by Node, with no <code>try</code> block around it. So if you use this anti-pattern, you'll end up crashing the program when you throw the error. Event in the case of an explicit <code>async</code> function that uses an <code>await</code> in the <code>try</code> block, an error thrown asynchronously won't be caught. Below is an example of an error that won't be caught.&#160;<a href="#fnref1:1" rev="footnote" class="footnote-backref">&#8617;</a></p> 